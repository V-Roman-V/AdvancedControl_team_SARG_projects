# Advanced Control Methods Project: Motorized Vessel Stabilization and Trajectory Tracking

## Overview

This project focuses on the **stabilization and trajectory tracking** of a motorized vessel using submerged rudder control with adaptive methods. The objective is to design a controller that drives the vessel to a desired goal state, ensuring stability and tracking in the presence of uncertainty.

The vessel is modeled with two thrusters providing control inputs. The controller uses **Lyapunov-based control** and an **adaptive component** to handle parameter uncertainties. The simulation is implemented using Python, and the repository includes modules for control computation, dynamics modeling, and visualization of the systemâ€™s behavior.

## Mathematical Model

### Vessel Kinematics

Let the state vector of the vessel be represented as:
\[
\mathbf{x} = \begin{bmatrix} x \\ y \\ \psi \\ V_x \\ V_y \\ \omega \end{bmatrix},
\]
where:
- \( x, y \) are the position coordinates,
- \( \psi \) is the yaw (heading),
- \( V_x, V_y \) are the surge and sway velocities (linear velocities in the body-fixed frame),
- \( \omega \) is the yaw rate.

The kinematic equations governing the vessel's motion are as follows:
\[
\begin{aligned}
\dot{x} &= V_x \cos(\psi) - V_y \sin(\psi), \\
\dot{y} &= V_x \sin(\psi) + V_y \cos(\psi), \\
\dot{\psi} &= \omega.
\end{aligned}
\]

### Vessel Dynamics

The vessel dynamics are driven by forces generated from the left and right thrusters. Let \( u_1 \) and \( u_2 \) be the control inputs corresponding to the left and right thrusters. The dynamics can be simplified as:
\[
\begin{aligned}
\dot{V}_x &= \frac{1}{m}\left(F_x(u_1, u_2)\right) - D_x V_x,\\
\dot{V}_y &= \frac{1}{m}\left(F_y(u_1, u_2)\right) - D_y V_y,\\
\dot{\omega} &= \frac{1}{I_z}\left(M(u_1, u_2)\right) - D_\psi\, \omega,
\end{aligned}
\]
where:
- \( m \) is the vessel's mass,
- \( I_z \) is the moment of inertia about the vertical axis,
- \( D_x, D_y, D_\psi \) are the damping coefficients,
- \( F_x, F_y \) are the forces due to the thrusters, and
- \( M \) is the moment generated by the thrusters.

### Control Objective

Let the desired state be \(\mathbf{x}_d = [x_d, y_d, \psi_d, V_{x,d}, V_{y,d}, \omega_d]^T\). The error between the actual and desired states is defined as:
\[
\mathbf{e} = \mathbf{x} - \mathbf{x}_d.
\]
The control objective is to design a control law \( \mathbf{u} = [u_1, u_2]^T \) such that the error dynamics are asymptotically stable.

### Lyapunov Control Design

A Lyapunov function candidate is defined as:
\[
V(\mathbf{e}) = \frac{1}{2}\mathbf{e}^T\mathbf{e}.
\]
The derivative of \( V(\mathbf{e}) \) with respect to time is:
\[
\dot{V} = \mathbf{e}^T\dot{\mathbf{e}}.
\]
The control law is designed to ensure that:
\[
\dot{V} \le -\alpha \|\mathbf{e}\|^2,
\]
where \( \alpha > 0 \) is a constant.

*TODO*

## Repository Structure

### `control.py`

This file contains the `VesselController` class, which computes the control inputs based on the vessel's state, desired state, and the regression function \( \phi(\mathbf{x}) \). It also implements the adaptive control law for parameter estimation.

### `boat.py`

The `Boat` class models the vessel's state and dynamics. It computes the evolution of the vessel's state over time, given the current control inputs. The state variables include position, velocity, yaw, and yaw rate.

### `visualization.py`

This module provides functions to visualize the vessel's trajectory and compare it with the desired trajectory. The `visualize` function uses Matplotlib to plot the vessel's path in the \(x\)-\(y\) plane.

### `main.py`

The `main.py` file is the entry point for the simulation. It initializes the vessel's state, sets up the controller, and runs the simulation loop. At each time step, the control inputs are computed, and the vessel's state is updated. The trajectory is then visualized.

## How to Run

To run the simulation, simply execute the `main.py` file:

```bash
python main.py
```

This will simulate the vessel's motion and plot the trajectory. The vessel will try to track the desired trajectory defined in the simulation, while the controller adapts to model uncertainties.
